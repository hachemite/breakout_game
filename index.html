<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout</title>
    <style>
        @font-face {
            font-family: pixel;
            src: url("https://dl.dropboxusercontent.com/s/hsdwvz761xqphhb/pixel.ttf");
        }
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
            -webkit-font-smoothing: none;
            image-rendering: pixelated;
        }
        form {
            top:-42vh;
            right: 14vw;
            position:fixed;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: pixel;
        }
        input[type="number"] {
            width: 70px;
            margin-right: 10px;
            font-family: pixel;
            background: #222;
            color: #fff;
            border: 2px solid #fff;
            padding: 5px;
            image-rendering: pixelated;
            -webkit-font-smoothing: none;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            font-family: pixel;
            background-color: #000;
            color: white;
            border: 2px solid #fff;
            cursor: pointer;
            image-rendering: pixelated;
            -webkit-font-smoothing: none;
        }
        button:hover {
            background-color: #fff;
            color: #000;
        }    </style></head>

<body>
    <form>
    <input type="number" id="stageInput" min="0" max="6" value="0" class="px-3 py-2" aria-label="Stage number" placeholder="Enter stage (0-2)">
    <button onclick="selectStage(event)" class="px-4 py-2">Load Stage</button>
    </form>
<script>
    const couleurs_mario = {
        r: '#D80000', // red
        b: '#706800', // brown
        o: '#F8AB00', // orange
        f: '#F83800', // fire
        w: '#FFFFFF', // white
        e: '#FFE0A8'  // beige
    } ;
    const couleurs_arkanoid = {
        w: "#FCFCFC", // white
        o: "#FC7460", // orange
        l: "#3CBCFC", // light blue
        g: "#80D010", // green
        r: "#D82800", // red
        b: "#0070EC", // blue
        p: "#FC74B4", // pink
        y: "#FC9838", // yellow
        s: "#BCBCBC", // silver
        d: "#F0BC3C"  // gold
    } ;
    const couleurs_pastel = {
        y: "#FFF7A5", // yellow
        p: "#FFA5E0", // pink
        b: "#A5B3FF", // blue
        g: "#BFFFA5", // green
        o: "#FFCBA5"  // orange
    } ;
    couleur_vintage = {
        a: "#EFD279", // yellow
        b: "#95CBE9", // light blue
        c: "#024769", // dark blue
        d: "#AFD775", // light green
        e: "#2C5700", // grass
        f: "#DE9D7F", // red
        g: "#7F9DDE", // purple
        h: "#00572C", // dark green
        i: "#75D7AF", // mint
        j: "#694702", // brown
        k: "#E9CB95", // peach
        l: "#79D2EF"  // blue
      };
      couleur_liquidplanner= {
        a: '#62C4E7', // light blue
        b: '#00A5DE', // dark  blue
        x: '#969699', // light gray
        y: '#7B797E'  // dark  gray
      }
      ball_colors = {
        b: '#111111', // black,
        w: '#EEEEEE', // white,
        c: '#EC7150', // cherry,
        s: '#B33A2F'  // shadow,
      }
   const stages = [
   [
   "yyyyyYYYYYyyyyyYYYYYyyyyyYYYYY",
   "pppppPPPPPpppppPPPPPpppppPPPPP",
   "bbbbbBBBBBbbbbbBBBBBbbbbbBBBBB",
   "gggggGGGGGgggggGGGGGgggggGGGGG",
   "oooooOOOOOoooooOOOOOoooooOOOOO"
   ],      
   [
   "          yy      yy          ",
   "            yy  yy            ",
   "            yy  yy            ", 
   "          ssSSssSSss          ",
   "          ssSSssSSss          ",
   "        SSsswwsswwssSS        ",
   "        SSsswwsswwssSS        ",
   "      ssSSssSSssSSssSSss      ",
   "      ssSSssSSssSSssSSss      ",
   "      ss  ssSSssSSss  ss      ",
   "      ss  ss      ss  ss      ",
   "      ss  ss      ss  ss      ",
   "            ss  ss            ",
   "            ss  ss            "
   ],
   [
   "",
   "oo",
   "ooll",
   "oollgg",
   "oollggbb",
   "oollggbbrr",
   "oollggbbrroo",
   "oollggbbrrooll",
   "oollggbbrroollgg",
   "oollggbbrroollggbb",
   "oollggbbrroollggbbrr",
   "oollggbbrroollggbbrroo",
   "oollggbbrroollggbbrrooll",
   "oollggbbrroollggbbrroollgg",
   "oollggbbrroollggbbrroollggbb",
   "ssSSssSSssSSssSSssSSssSSssSSrr"
   ],
   [
   "              ss              ",
   "          bbBBssggGG          ",
   "        BBbbWWwwWWGGgg        ",
   "      bbBBwwWWwwWWwwggGG      ",
   "      bbBBwwWWwwWWwwggGG      ",
   "      bbBBwwWWwwWWwwggGG      ",
   "      ss  ss  ss  ss  ss      ",
   "              ss              ",
   "              ss              ",
   "          oo  oo              ",
   "          ooOOoo              ",
   "            OO                "
   ],
   [
   "   AAaaAAaaAAaaAAaaAAaaAAaa   ",
   "    BBbbBBbbBBbbBBbbBBbbBB    ",
   "     CCccCCccCCccCCccCCcc     ",
   "      DDddDDddDDddDDddDD      ",
   "       EEeeEEeeEEeeEEee       ",
   "        FFffFFffFFffFF        ",
   "         GGggGGggGGgg         ",
   "          HHhhHHhhHH          ",
   "           IIiiIIii           ",
   "            JJjjJJ            ",
   "             KKkk             ",
   "              LL              ",
   "              A               "
   ],
   [
   "",
   "       bBb                    ",
   "      BcCcB                   ",
   "     bCwCcsb  b               ",
   "     bCcCcsb b                ",
   "      BcCsB B                 ",
   "    BbBsSsBbB       bBb       ",
   "   bcCcbBbcCcb     BcCcB      ",
   "  bcwcCsbcwcCsb   bCwCcsb  b  ",
   "  bcCcCsbcCcCsb   bCcCcsb b   ",
   "  bcCcsSbcCcsSb    BcCsB B    ",
   "   bsSsb bsSsb   BbBsSsBbB    ",
   "    bBb   bBb   bcCcbBbcCcb   ",
   "               bcwcCsbcwcCsb   ",
   "               bcCcCsbcCcCsb   ",
   "               bcCcsSbcCcsSb   ",
   "                bsSsb bsSsb    ",
   "                 bBb   bBb     "
   ],
   [
   "",
   "    rRrRr                     ",
   "   RrRrRrRrR                  ",
   "   BbBoObo                    ",
   "  boboOoboOo       F    f   f ",
   "  bobBoOoboOo     f e         ",
   "  bBoOoObBbB       F  f     e ",
   "    oOoOoOo        Ff      E  ",
   "   bBrbBb        E  f fF F  f ",
   "  bBbrbBrbBb       FfFfFf  F  ",
   " bBbBrRrRbBbB     fFeFeFfFf   ",
   " oObrorRorboO    FfEeEeEfF    ",
   " oOorRrRrRoOo    FeEeWwEeFf   ",
   " oOrRrRrRrRoO   fFeFwWfEeFf   ",
   "   rRr  RrR     fFeFwWfEeFf   ",
   "  bBb    bBb    fFeEwWeEeFf   ",
   " bBbB    bBbB   fFfEeEeEfF    ",
   "                 FfFfFfFfF     ",
   "                   FfFfF       "
   ]
];
    
        // set up the game canvas and context
        var canv = document.createElement("canvas");
        document.body.appendChild(canv);
        var ctx = canv.getContext("2d");
    // game parameters
    const BALL_SPD = 0.5; // starting ball speed as a fraction of screen height per second
    const BALL_SPD_MAX = 2; // max ball speed as a multiple of starting speed
    const BALL_SPIN = 0.2; // ball deflection off the paddle (0 = no spin, 1 = high spin)
    const BRICK_COLS = 14; // number of brick columns
    const BRICK_GAP = 0.3; // brick gap as a fraction of wall width
    const BRICK_ROWS = 8; // starting number of brick rows
    const GAME_LIVES = 3; // starting number of game lives
    const KEY_SCORE = "breakout_highscore"; // save key for local storage of high score
    const MARGIN = 6; // number of empty rows above the bricks
    const MAX_LEVEL = 10; // maximum game level (+2 rows of bricks per level)
    const MIN_BOUNCE_ANGLE = 30; // minimum bounce angle from the horizontal in degrees
    const PADDLE_SIZE = 1.5; // paddle size as a multiple of wall thickness
    const PADDLE_SPD = 0.5; // fraction of screen width per second
    const PADDLE_W = 0.1; // paddle width as a fraction of screen width
    const PUP_BONUS = 50; // bonus points for collecting an extra powerup
    const PUP_CHANCE = 0.1; // probability of a powerup per brick hit (between 0 and 1)
    const PUP_SPD = 0.15; // powerup speed as a fraction of screen height per second
    const WALL = 0.02; // wall/ball size as a fraction of the shortest screen dimension

    // colours
    const COLOR_BACKGROUND = "black";
    const COLOR_BALL = "white";
    const COLOR_PADDLE = "white";
    const COLOR_TEXT = "white";
    const COLOR_WALL = "grey";

    // text
    const TEXT_FONT = "pixel";
    const TEXT_GAME_OVER = "GAME OVER";
    const TEXT_LEVEL = "Level";
    const TEXT_LIVES = "Ball";
    const TEXT_SCORE = "Score";
    const TEXT_SCORE_HIGH = "BEST";
    const TEXT_WIN = "!!! YOU WIN !!!";

    // definitions
    const Direction = {
        LEFT: 0,
        RIGHT: 1,
        STOP: 2
    }

    const PupType = {
        EXTENSION: {color: "dodgerblue", symbol: "="},
        LIFE: {color: "hotpink", symbol: "+"},
        STICKY: {color: "forestgreen", symbol: "~"},
        SUPER: {color: "magenta", symbol: "s"}
    }



    // set up sound effects
    var fxBrick = new Audio("sounds/Ball bounce off normal brick - destroy.wav");
    var fxPaddle = new Audio("sounds/Ball bounce off the player paddle.wav");
    var fxPowerup = new Audio("sounds/pickup_bulletTrail.wav");
    var fxWall = new Audio("sounds/Ball bounce off the sides of the screen.wav");
    var fxHit = new Audio("sounds/pl000_dam.wav");
    var fxstage1 = new Audio("sounds/Kirby Breakout.mp3");

    var fxstage2 = new Audio("sounds/Mario Takes a Stroll Through the Birabuto Kingdom.mp3");
    var fxstage3 = new Audio("sounds/05_ Cosmic Chaos, Act 1.mp3");
    var fxSizeincrease = new Audio("sounds/Paddle Size increase.wav");
    var fxgameover = new Audio("sounds/Game Over sound effect [TubeRipper.com].mp3");

    let songplaying = null;

    function playsong(songName) {
        // Create a new audio element for the song
        const song = songName;
    
        // Stop the currently playing song, if there is one
        if (songplaying) {
            songplaying.pause();
            songplaying.currentTime = 0; // Reset to the beginning in case it's resumed
        }
    
        // Play the new song and set it as the currently playing song
        song.play()
            .then(() => {
                songplaying = song; // Update songplaying to the new song
            })
            .catch(error => {
                console.error("Error playing the song:", error); // Error handling for playback issues
            });
    }


    // game variables
    var ball, bricks = [], paddle, pups = [];
    var gameOver, pupExtension, pupSticky, pupSuper, win;
    var level, lives, score, scoreHigh;
    var numBricks, textSize, touchX;

    // dimensions
    var height, width, wall;
    setDimensions();

    // event listeners
    canv.addEventListener("touchcancel", touchCancel);
    canv.addEventListener("touchend", touchEnd);
    canv.addEventListener("touchmove", touchMove);
    canv.addEventListener("touchstart", touchStart);
    document.addEventListener("keydown", keyDown);
    document.addEventListener("keyup", keyUp);
    window.addEventListener("resize", setDimensions);

    // set up the game loop
    var timeDelta, timeLast;
    requestAnimationFrame(loop);

    function loop(timeNow) {
        if (!timeLast) {
            timeLast = timeNow;
        }

        // calculate the time difference
        timeDelta = (timeNow - timeLast) * 0.001; // seconds
        timeLast = timeNow;

        // update
        if (!gameOver) {
            updatePaddle(timeDelta);
            updateBall(timeDelta);
            updateBricks(timeDelta);
            updatePups(timeDelta);
        }

        // draw


        drawBackground();
        drawWalls();
        drawPups();
        drawPaddle();
        drawBricks();
        drawText();
        drawBall();

        // call the next loop
        requestAnimationFrame(loop);
    }

    // update the x and y velocities of the ball
    function applyBallSpeed(angle) {
        ball.xv = ball.spd * Math.cos(angle);
        ball.yv = -ball.spd * Math.sin(angle);
    }



    function createBricks() {

        // row dimensions
        let minY = wall;
        let maxY = ball.y - ball.h * 3.5;
        let totalSpaceY = maxY - minY;
        let totalRows = MARGIN + stages[level].length+ MAX_LEVEL * 2;
        let rowH = totalSpaceY / totalRows;
        let gap = wall * BRICK_GAP;
        let h = rowH - gap;
        textSize = rowH * MARGIN * 0.5;

        // column dimensions
        let totalSpaceX = width - wall * 2;
        let colW = (totalSpaceX - gap) / BRICK_COLS;
        let w = colW - gap;

        // populate the bricks array
        bricks = [];
        let cols = BRICK_COLS;
        let rows = BRICK_ROWS + level * 2;
        let color, left, rank, rankHigh, score, spdMult, top;
        numBricks = cols * rows;
        rankHigh = rows * 0.5 - 1;
        for (let i = 0; i < stages[level].length; i++) {
            bricks[i] = [];
            rank = Math.floor(i * 0.5);
            score = Math.abs((rankHigh - rank) * 6 + 1);
            spdMult = 1 + (rankHigh - rank) / rankHigh * (BALL_SPD_MAX - 1);
            color = getBrickColor(rank, rankHigh);
            top = wall + (MARGIN + i) * rowH;
            let colW = (totalSpaceX - gap) / stages[level][i].length;
            let w = colW - gap;
            for (let j = 0; j < stages[level][i].length; j++) {
                let char = stages[level][i][j];
                if (char === " ") continue;
                
                left = wall + gap + j * colW;
                bricks[i][j] = new Brick(left, top, w, h, color, score, spdMult);
            }
        }
    }
    function drawBackground() {
        // Create a gradient background
        let gradient = ctx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, '#000033');
        gradient.addColorStop(1, '#330033');
        ctx.fillStyle = COLOR_BACKGROUND;
        ctx.fillRect(0, 0, width, height);
        
        // Add twinkling stars
        for (let i = 0; i < 30; i++) {
            let x = Math.random() * width;
            let y = Math.random() * height;
            let size = Math.random() * 2;
            let opacity = Math.random();
            
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Add a subtle glow effect
        ctx.fillStyle = 'rgba(0, 0, 0, 0)';
        ctx.fillRect(0, height * 0.7, width, height * 0.3);
    }

    function drawBall() {
        ctx.fillStyle = pupSuper ? PupType.SUPER.color : COLOR_BALL;
        
        // Add motion blur effect
        ctx.shadowColor = pupSuper ? PupType.SUPER.color : COLOR_BALL;
        ctx.shadowBlur = Math.abs(ball.xv) + Math.abs(ball.yv);
        ctx.shadowOffsetX = -ball.xv * 0.5;
        ctx.shadowOffsetY = -ball.yv * 0.5;
        
        ctx.fillRect(ball.x - ball.w * 0.5, ball.y - ball.h * 0.5, ball.w, ball.h);
        
        // Reset shadow effects
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        

            
            }


    
    function drawBricks() {
        for (let i = 0; i < stages[level].length; i++) {
            for (let j = 0; j < stages[level][i].length; j++) {
                if (bricks[i][j]) {
                    var color = stages[level][i][j].toLowerCase();
                    if(level==0){
                        ctx.fillStyle = couleurs_pastel[color];
                    }
                    else if(level == 1|| level==2 || level==3){
                        ctx.fillStyle = couleurs_arkanoid[color];
                    }
                    else if(level ==4 ){
                        ctx.fillStyle = couleur_vintage[color];
                    }
                    else if(level ==5 ){
                        ctx.fillStyle = ball_colors[color];
                    }
                    else if(level ==6){
                        ctx.fillStyle = couleurs_mario[color];

                    }
                    else {
                        ctx.fillStyle = "#ffffff";
                    }
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    
                    // Draw brick with border
                    ctx.fillRect(bricks[i][j].left, bricks[i][j].top, bricks[i][j].w, bricks[i][j].h);
                    ctx.strokeRect(bricks[i][j].left, bricks[i][j].top, bricks[i][j].w, bricks[i][j].h);
                }
            }
        }
    }
    function drawPaddle() {
        ctx.fillStyle = pupSticky ? PupType.STICKY.color : COLOR_PADDLE;
        ctx.strokeStyle = 'gold';
        ctx.lineWidth = 2;
    
        // Create rounded rectangle path
        let x = paddle.x - paddle.w * 0.5;
        let y = paddle.y - paddle.h * 0.5;
        let radius = paddle.h * 0.5;
    
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + paddle.w - radius, y);
        ctx.arcTo(x + paddle.w, y, x + paddle.w, y + radius, radius);
        ctx.lineTo(x + paddle.w, y + paddle.h - radius);
        ctx.arcTo(x + paddle.w, y + paddle.h, x + paddle.w - radius, y + paddle.h, radius);
        ctx.lineTo(x + radius, y + paddle.h);
        ctx.arcTo(x, y + paddle.h, x, y + paddle.h - radius, radius);
        ctx.lineTo(x, y + radius);
        ctx.arcTo(x, y, x + radius, y, radius);
        ctx.closePath();
    
        // Add neon glow effect
        ctx.shadowColor = pupSticky ? PupType.STICKY.color : COLOR_PADDLE;
        ctx.shadowBlur = 10;
        ctx.fill();
        ctx.stroke();
        ctx.shadowBlur = 0;
    }
        function drawPups() {
            ctx.lineWidth = wall * 0.35;
            for (let pup of pups) {
                // Add pixelated effect with multiple outlines
                ctx.fillStyle = "pup.type.color";
                ctx.strokeStyle = '#ffffff';
            
                // Main power-up box with zigzag pattern
                ctx.beginPath();
                let x = pup.x - pup.w * 0.5;
                let y = pup.y - pup.h * 0.5;
            
                // Create glowing effect
                ctx.shadowColor = pup.type.color;
                ctx.shadowBlur = 15;
                
                // Draw outer box with slight offset
                ctx.strokeRect(x - 2, y - 2, pup.w + 4, pup.h + 4);
                ctx.strokeStyle = pup.type.color;
                ctx.strokeRect(x, y, pup.w, pup.h);
                
                // Add inner glow
                ctx.fillStyle = "pup.type.color" + '44';
                ctx.fillRect(x, y, pup.w, pup.h);
            
                // Draw pulsing border
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = wall * 0.2 * (1 + Math.sin(Date.now() * 0.01));
                ctx.strokeRect(x - 4, y - 4, pup.w + 8, pup.h + 8);
            
                // Draw symbol with retro shadow and glow
                ctx.font = "bold " + pup.h + "px " + TEXT_FONT;
                ctx.textAlign = "center";
                ctx.shadowBlur = 10;
                ctx.fillStyle = '#000000';
                ctx.fillText(pup.type.symbol, pup.x + 2, pup.y + 2);
                ctx.fillStyle = '#ffffff';
                ctx.fillText(pup.type.symbol, pup.x + 1, pup.y + 1);
                ctx.fillStyle = pup.type.color;
                ctx.fillText(pup.type.symbol, pup.x, pup.y);
                
                // Add rotating particles
                let time = Date.now() * 0.003;
                for (let i = 0; i < 4; i++) {
                    let angle = time + (Math.PI * 2 * i / 4);
                    let px = pup.x + Math.cos(angle) * (pup.w * 0.7);
                    let py = pup.y + Math.sin(angle) * (pup.h * 0.7);
                    ctx.beginPath();
                    ctx.arc(px, py, 2, 0, Math.PI * 2);
                    ctx.fillStyle = '#ffffff';
                    ctx.fill();
                }
                
                // Reset shadow
                ctx.shadowBlur = 0;
            }
        }

    function drawText() {
        ctx.fillStyle = COLOR_TEXT;

        // dimensions
        let labelSize = textSize * 0.375;  // Reduced by 25%
        let margin = wall * 1.5;  // Reduced by 25%
        let maxWidth = width - margin * 2;
        let maxWidth1 = maxWidth * 0.2025;  // Reduced by 25%
        let maxWidth2 = maxWidth * 0.15;  // Reduced by 25%
        let maxWidth3 = maxWidth * 0.15;  // Reduced by 25%
        let maxWidth4 = maxWidth * 0.2025;  // Reduced by 25%
        let x1 = margin;
        let x2 = width * 0.4;
        let x3 = width * 0.6;
        let x4 = width - margin;
        let yLabel = wall + labelSize;
        let yValue = yLabel + textSize * 0.675;  // Reduced by 25%

        // Draw retro scoreboard background
        ctx.fillStyle = "#000000";
        ctx.strokeStyle = "#444444";
        ctx.lineWidth = 2.25;  // Reduced by 25%
        ctx.fillRect(wall, wall * 0.375, width - wall * 2, yValue + textSize * 0.375);
        ctx.strokeRect(wall, wall * 0.375, width - wall * 2, yValue + textSize * 0.375);

        // Draw grid separators
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 4.5;  // Reduced by 25%
        ctx.setLineDash([6, 3]); // Create pixelated effect, reduced by 25%
        ctx.beginPath();
        ctx.moveTo(width * 0.3, wall * 0.375);
        ctx.lineTo(width * 0.3, yValue + textSize * 0.375);
        ctx.moveTo(width * 0.5, wall * 0.375);
        ctx.lineTo(width * 0.5, yValue + textSize * 0.375);
        ctx.moveTo(width * 0.7, wall * 0.375);
        ctx.lineTo(width * 0.7, yValue + textSize * 0.375);
        ctx.stroke();
        ctx.setLineDash([]); // Reset line style        // labels
        ctx.font = labelSize + "px " + TEXT_FONT;
        ctx.shadowColor = "#ff0000";
        ctx.shadowBlur = 3.75;  // Reduced by 25%
        ctx.fillStyle = "#ff4444";
        ctx.textAlign = "left";
        ctx.fillText(TEXT_SCORE, x1, yLabel, maxWidth1);
        
        ctx.shadowColor = "#00ff00";
        ctx.fillStyle = "#44ff44";
        ctx.textAlign = "center";
        ctx.fillText(TEXT_LIVES, x2, yLabel, maxWidth2);
        
        ctx.shadowColor = "#0000ff";
        ctx.fillStyle = "#4444ff";
        ctx.fillText(TEXT_LEVEL, x3, yLabel, maxWidth3);
        
        ctx.shadowColor = "#ffff00";
        ctx.fillStyle = "#ffff44";
        ctx.textAlign = "right";
        ctx.fillText(TEXT_SCORE_HIGH, x4, yLabel, maxWidth4);

        // Values
        ctx.font = textSize * 0.75 + "px " + TEXT_FONT;  // Reduced by 25%
        ctx.shadowColor = "#ff0000";
        ctx.fillStyle = "#ff8888";
        ctx.textAlign = "left";
        ctx.fillText(score, x1, yValue, maxWidth1);
        
        ctx.shadowColor = "#00ff00";
        ctx.fillStyle = "#88ff88";
        ctx.textAlign = "center";
        ctx.fillText(lives + "/" + GAME_LIVES, x2, yValue, maxWidth2);
        
        ctx.shadowColor = "#0000ff";
        ctx.fillStyle = "#8888ff";
        ctx.fillText(level, x3, yValue, maxWidth3);
        
        ctx.shadowColor = "#ffff00";
        ctx.fillStyle = "#ffff88";
        ctx.textAlign = "right";
        ctx.fillText(scoreHigh, x4, yValue, maxWidth4);
                ctx.shadowBlur = 0;        // game over
        if (gameOver) {
            let text = win ? TEXT_WIN : TEXT_GAME_OVER;
            ctx.font = "bold " + textSize+80 + "px " + TEXT_FONT;
            ctx.textAlign = "center";
            ctx.shadowColor = win ? "#ff0000" : "#ff0000";
            ctx.shadowBlur = 5;
            ctx.fillStyle = gameOver && !win ? "#ff0000" : "#ff3333";
            
            // Add rectangle border
            let textMetrics = ctx.measureText(text);
            let padding = 20;
            ctx.strokeStyle = gameOver && !win ? "#ff0000" : "#ff3333";
            ctx.lineWidth = 3;
            ctx.strokeRect(
                width * 0.5 - textMetrics.width / 2 - padding,
                height * 0.5 - 50 - padding,
                textMetrics.width + padding * 2,
                100 + padding * 2
            );
            
            ctx.fillText(text, width * 0.5, height * 0.5, maxWidth);
            ctx.strokeStyle = "#ff0000";
            ctx.lineWidth = 2;
            ctx.strokeText(text, width * 0.5, height * 0.5, maxWidth);
            ctx.shadowBlur = 0;        
        }   
        // powerup text
                if (pupExtension||pupSticky ||pupSuper ) {
                    let text = "POWER UP!";
                    ctx.globalAlpha = 0.7; // Add transparency
                    ctx.font = "bold " + textSize * 1.2 + "px " + TEXT_FONT;
                    ctx.textAlign = "center";
                    
                    // Smoother rainbow color animation with slower cycle
                    const hue = (Date.now() / 30) % 360;
                    // Add bouncing animation
                    const bounce = Math.sin(Date.now() / 200) * 15;
                    
                    ctx.shadowColor = `hsla(${hue}, 100%, 50%, 0.6)`;
                    ctx.shadowBlur = 35;
                    ctx.fillStyle = `hsla(${hue}, 100%, 60%, 0.7)`;
                    
                    // Larger centered rectangle with dynamic glow
   
                    
                    // Text with rainbow outline
                    ctx.fillText(text, width * 0.5, height * 0.6 + bounce);
                    ctx.strokeStyle = `hsla(${(hue + 90) % 360}, 100%, 50%, 0.4)`;
                    ctx.lineWidth = 3;
                    ctx.strokeText(text, width * 0.5, height * 0.6 + bounce);
                    
                    // Reset shadow and opacity
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1.0;
                    
                    // Smoothly fade out power-up display over 3 seconds
                    let fadeStart = Date.now();
                    let fadeInterval = setInterval(() => {
                        let elapsed = Date.now() - fadeStart;
                        let opacity = 1 - (elapsed / 3000);
                        if (opacity <= 0) {
                            clearInterval(fadeInterval);
                            pupExtension = false;
                            pupSticky = false;
                            pupSuper = false;
                        }
                    }, 16)
                }
            }; // Update roughly every frame (60fps)                }                 }

    function drawWalls() {
        let hwall = wall * 0.5;
        ctx.lineWidth = wall;
        ctx.strokeStyle = COLOR_WALL;
        ctx.beginPath();
        ctx.moveTo(hwall, height);
        ctx.lineTo(hwall, hwall);
        ctx.lineTo(width - hwall, hwall);
        ctx.lineTo(width - hwall, height);
        ctx.stroke();
    }

    // red = 0, orange = 0.33, yellow = 0.67, green = 1
    function getBrickColor(rank, highestRank) {
        let fraction = rank / highestRank;
        let r, g, b = 0;

        // red to orange to yellow (increase green)
        if (fraction <= 0.67) {
            r = 255;
            g = 255 * fraction / 0.67;
        }

        // yellow to green (reduce red)
        else {
            r = 255 * (1 - fraction) / 0.33;
            g = 255;
        }

        // return the rgb colour string
        return "rgb(" + r + ", " + g + ", " + b + ")";
    }

    function keyDown(ev) {
        switch (ev.keyCode) {
            case 32: // space bar (serve the ball)
                serve();
                if (gameOver) {
                    newGame();
                }
                break;
            case 37: // left arrow (move paddle left)
                movePaddle(Direction.LEFT);
                break;
            case 39: // right arrow (move paddle right)
                movePaddle(Direction.RIGHT);
                break;
        }
    }

    function keyUp(ev) {
        switch (ev.keyCode) {
            case 37: // left arrow (stop moving)
            case 39: // right arrow (stop moving)
                movePaddle(Direction.STOP);
                break;
        }
    }

    function movePaddle(direction) {
        switch (direction) {
            case Direction.LEFT:
                paddle.xv = -paddle.spd;
                break;
            case Direction.RIGHT:
                paddle.xv = paddle.spd;
                break;
            case Direction.STOP:
                paddle.xv = 0;
                break;
        }
    }

    function newBall() {
        pupExtension = false;
        pupSticky = false;
        pupSuper = false;
        paddle = new Paddle();
        ball = new Ball();
    }

    function newGame() {
        gameOver = false;
        level = 0;
        lives = GAME_LIVES;
        score = 0;
        win = false;

        // get high score from local storage
        let scoreStr = localStorage.getItem(KEY_SCORE);
        if (scoreStr == null) {
            scoreHigh = 0;
        } else {
            scoreHigh = parseInt(scoreStr);
        }
        playsong(fxstage1);
        // start a new level
        newLevel();
        

    }
    function musichandler() {
        if (level % 2 == 0) {
                fxstage2.stop();
                fxstage1.play();
            }
        else {
            fxstage1.stop();
            fxstage2.play();
        }
    }

    function newLevel() {
        pups = [];
        touchX = null;
        newBall();
        createBricks();
        if (level == 0 || level == 2 || level == 3) {
            playsong(fxstage1);
        }
        if (level == 1 || level == 4) {
            playsong(fxstage3);
           
        }
        if (level == 5 || level == 6) {
            playsong(fxstage2);
        }
       
    }

    function outOfBounds() {

        lives--;
        if (lives == 0) {
            gameOver = true;
            fxgameover.play();

        }
        fxHit.play();
        newBall();
    }

    function serve() {

        // ball already in motion
        if (ball.yv != 0) {
            return false;
        }

        // random angle (not less than min bounce angle)
        let minBounceAngle = MIN_BOUNCE_ANGLE / 180 * Math.PI; // radians
        let range = Math.PI - minBounceAngle * 2;
        let angle = Math.random() * range + minBounceAngle;
        applyBallSpeed(pupSticky ? Math.PI / 2 : angle);
        fxPaddle.play();
        return true;
    }

    function setDimensions() {
        height = window.innerHeight;
        width = window.innerWidth;
        wall = WALL * (height < width ? height : width);
        canv.width = width;
        canv.height = height;
        ctx.textBaseline = "middle";
        newGame();
    }

    function spinBall() {
        let upwards = ball.yv < 0;
        let angle = Math.atan2(-ball.yv, ball.xv);
        angle += (Math.random() * Math.PI / 2 - Math.PI / 4) * BALL_SPIN;

        // minimum bounce angle
        let minBounceAngle = MIN_BOUNCE_ANGLE / 180 * Math.PI; // radians
        if (upwards) {
            if (angle < minBounceAngle) {
                angle = minBounceAngle;
            } else if (angle > Math.PI - minBounceAngle) {
                angle = Math.PI - minBounceAngle;
            }
        } else {
            if (angle > -minBounceAngle) {
                angle = -minBounceAngle;
            } else if (angle < -Math.PI + minBounceAngle) {
                angle = -Math.PI + minBounceAngle;
            }
        }
        applyBallSpeed(angle);
    }

    function touchCancel(ev) {
        touchX = null;
        movePaddle(Direction.STOP);
    }

    function touchEnd(ev) {
        touchX = null;
        movePaddle(Direction.STOP);
    }

    function touchMove(ev) {
        touchX = ev.touches[0].clientX;
    }

    function touchStart(ev) {
        if (serve()) {
            if (gameOver) {
                newGame();
            }
            return;
        }
        touchX = ev.touches[0].clientX;
    }

    function updateBall(delta) {
        ball.x += ball.xv * delta;
        ball.y += ball.yv * delta;

        // bounce the ball off the walls
        if (ball.x < wall + ball.w * 0.5) {
            ball.x = wall + ball.w * 0.5;
            ball.xv = -ball.xv;
            fxWall.play();
            spinBall();
        } else if (ball.x > width - wall - ball.w * 0.5) {
            ball.x = width - wall - ball.w * 0.5;
            ball.xv = -ball.xv;
            fxWall.play();
            spinBall();
        } else if (ball.y < wall + ball.h * 0.5) {
            ball.y = wall + ball.h * 0.5;
            ball.yv = -ball.yv;
            fxWall.play();
            spinBall();
        }

        // bounce off the paddle
        if (ball.y > paddle.y - paddle.h * 0.5 - ball.h * 0.5
            && ball.y < paddle.y + paddle.h * 0.5
            && ball.x > paddle.x - paddle.w * 0.5 - ball.w * 0.5
            && ball.x < paddle.x + paddle.w * 0.5 + ball.w * 0.5
        ) {
            ball.y = paddle.y - paddle.h * 0.5 - ball.h * 0.5;
            paddle.y = paddle.y + 5;
            paddle.y = paddle.y -2;
            paddle.y = paddle.y -2;
            paddle.y = paddle.y -1;



            paddle.y = paddle.y + 1;
            if (pupSticky) {
                ball.xv = 0;
                ball.yv = 0;
            } else {
                ball.yv = -ball.yv;
                spinBall();
            }
            fxPaddle.play();
        }

        // handle out of bounds
        if (ball.y > height) {
            outOfBounds();
        }
    }

    function updateBricks(delta) {

        // check for ball collisions
        OUTER: for (let i = 0; i < bricks.length; i++) {
            for (let j = 0; j < stages[level][i].length; j++) {
                if (bricks[i][j] != null && bricks[i][j].intersect(ball)) {
                    updateScore(bricks[i][j].score);
                    ball.setSpeed(bricks[i][j].spdMult);

                    // set ball to the edge of the brick
                    if (ball.yv < 0) { // upwards
                        ball.y = bricks[i][j].bot + ball.h * 0.5;
                    } else { // downwards
                        ball.y = bricks[i][j].top - ball.h * 0.5;
                    }

                    // create a powerup
                    if (Math.random() <= PUP_CHANCE) {
                        let px = bricks[i][j].left + bricks[i][j].w / 2;
                        let py = bricks[i][j].top + bricks[i][j].h / 2;
                        let pSize = bricks[i][j].w / 2;
                        let pKeys = Object.keys(PupType);
                        let pKey = pKeys[Math.floor(Math.random() * pKeys.length)];
                        pups.push(new PowerUp(px, py, pSize, PupType[pKey]));
                    }

                    // bounce the ball (if not a super ball) and destroy the brick
                    if (!pupSuper) {
                        ball.yv = -ball.yv;
                    }
                    bricks[i][j] = null;
                    numBricks--;
                    fxBrick.play();
                    spinBall();
                    break OUTER;
                }
            }
        }

        // next level
        if (numBricks == 0) {
            if (level < MAX_LEVEL) {
                level++;
                newLevel();
            } else {
                gameOver = true;
                win = true;
                newBall();
            }
        }
    }

    function updatePaddle(delta) {

        // handle touch
        if (touchX != null) {
            if (touchX > paddle.x + wall) {
                movePaddle(Direction.RIGHT);
            } else if (touchX < paddle.x - wall) {
                movePaddle(Direction.LEFT);
            } else {
                movePaddle(Direction.STOP);
            }
        }

        // move the paddle
        let lastPaddleX = paddle.x;
        paddle.x += paddle.xv * delta;

        // stop paddle at walls
        if (paddle.x < wall + paddle.w * 0.5) {
            paddle.x = wall + paddle.w * 0.5;
        } else if (paddle.x > width - wall - paddle.w * 0.5) {
            paddle.x = width - wall - paddle.w * 0.5;
        }

        // move the stationary ball with the paddle
        if (ball.yv == 0) {
            ball.x += paddle.x - lastPaddleX;
        }

        // collect powerups
        for (let i = pups.length - 1; i >= 0; i--) {
            if (
                pups[i].x + pups[i].w * 0.5 > paddle.x - paddle.w * 0.5
                && pups[i].x - pups[i].w * 0.5 < paddle.x + paddle.w * 0.5
                && pups[i].y + pups[i].h * 0.5 > paddle.y - paddle.h * 0.5
                && pups[i].y - pups[i].h * 0.5 < paddle.y + paddle.h * 0.5
            ) {
                switch(pups[i].type) {
                    case PupType.EXTENSION:
                        // double the width of the paddle
                        if (pupExtension) {
                            score += PUP_BONUS;
                        } else {
                            fxSizeincrease.play();
                            pupExtension = true;
                            paddle.w *= 2;
                        }
                        break;
                    case PupType.LIFE:
                        // add a life
                        lives++;
                        break;
                    case PupType.STICKY:
                        if (pupSticky) {
                            score += PUP_BONUS;
                        } else {
                            pupSticky = true;
                        }
                        break;
                    case PupType.SUPER:
                        if (pupSuper) {
                            score += PUP_BONUS;
                        } else {
                            pupSuper = true;
                        }
                        break;
                }
                pups.splice(i, 1);
                fxPowerup.play();
            }
        }
    }

    function updatePups(delta) {
        for (let i = pups.length - 1; i >= 0; i--) {
            pups[i].y += pups[i].yv * delta;

            // delete off-screen pups
            if (pups[i].y - pups[i].h * 0.5 > height) {
                pups.splice(i, 1);
            }
        }
    }

    function updateScore(brickScore) {
        score += brickScore;

        // check for a high score
        if (score > scoreHigh) {
            scoreHigh = score;
            localStorage.setItem(KEY_SCORE, scoreHigh);
        }
    }

    function Ball() {
        this.w = wall;
        this.h = wall;
        this.x = paddle.x;
        this.y = paddle.y - paddle.h / 2 - this.h / 2;
        this.spd = BALL_SPD * height;
        this.xv = 0;
        this.yv = 0;

        this.setSpeed = function(spdMult) {
            this.spd = Math.max(this.spd, BALL_SPD * height * spdMult);
        }
    }

    function Brick(left, top, w, h, color, score, spdMult) {
        this.w = w;
        this.h = h;
        this.bot = top + h;
        this.left = left;
        this.right = left + w;
        this.top = top;
        this.color = color;
        this.score = score;
        this.spdMult = spdMult;

        this.intersect = function(ball) {
            let bBot = ball.y + ball.h * 0.5;
            let bLeft = ball.x - ball.w * 0.5;
            let bRight = ball.x + ball.w * 0.5;
            let bTop = ball.y - ball.h * 0.5;
            return this.left < bRight
                && bLeft < this.right
                && this.bot > bTop
                && bBot > this.top;
        }
    }

    function Paddle() {
        this.w = PADDLE_W * width;
        this.h = wall * PADDLE_SIZE;
        this.x = width / 2;
        this.y = height - wall * 3.5 + this.h / 2;
        this.spd = PADDLE_SPD * width;
        this.xv = 0;
    }

    function PowerUp(x, y, size, type) {
        this.w = size;
        this.h = size;
        this.x = x;
        this.y = y;
        this.type = type;
        this.yv = PUP_SPD * height;
    }



    
function selectStage(event) {
    event.preventDefault();
    const stageNumber = document.getElementById('stageInput').value;
    if (stageNumber >= 0 && stageNumber <= 6) {
        gameOver = false;
        level = stageNumber;
        lives = GAME_LIVES;
        score = 0;
        win = false;

        // get high score from local storage
        let scoreStr = localStorage.getItem(KEY_SCORE);
        if (scoreStr == null) {
            scoreHigh = 0;
        } else {
            scoreHigh = parseInt(scoreStr);
        }
        newLevel();


    
    }
}
</script>
</body>

</html>